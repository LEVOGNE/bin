#!/usr/bin/env zsh
# ============================================
#  PATH Cleaner & Sorter for Zsh
#  Autor: LEVOGNE (admin@lesigns.de)
#  Lizenz: MIT
#
#  Zweck:
#  Dieses Script bereinigt und optimiert die PATH-Variable:
#   â€¢ Entfernt doppelte EintrÃ¤ge
#   â€¢ Entfernt leere oder nicht existente Verzeichnisse
#   â€¢ Sortiert User-Pfade nach vorne, System-Pfade nach hinten
#   â€¢ Bietet Vorschau und optionale Aktivierung
# ============================================

# ğŸ”§ PATH in ein Array umwandeln, damit jeder Eintrag separat verarbeitet werden kann
typeset -a path_array
path_array=("${(s/:/)PATH}")

# ğŸ§¼ Bereinigung: Doppelte, leere und nicht-existente Verzeichnisse entfernen
typeset -A seen_paths  # assoziatives Array, um Duplikate zu erkennen
typeset -a cleaned     # bereinigte Pfadliste

for path in "${path_array[@]}"; do
  if [[ -n "$path" && -d "$path" && -z ${seen_paths[$path]} ]]; then
    cleaned+=("$path")      # nur gÃ¼ltige, einmalige Pfade Ã¼bernehmen
    seen_paths[$path]=1     # merken, dass dieser Pfad bereits erfasst wurde
  fi
done

# ğŸ“š Sortierung:
#   User-spezifische Pfade zuerst (z.B. ~/bin)
#   System-Pfade (z.B. /usr/bin, /System, /opt) danach
user_paths=()
system_paths=()

for path in "${cleaned[@]}"; do
  if [[ "$path" == /usr/* || "$path" == /System/* || "$path" == /opt/* || "$path" == /Library/* ]]; then
    system_paths+=("$path")
  else
    user_paths+=("$path")
  fi
done

# ğŸ” Bereinigte Pfade wieder zu einer PATH-Variable zusammensetzen
new_path="${(j.:.)user_paths}:${(j.:.)system_paths}"

# âœ… Vorschau anzeigen
echo -e "\n\033[1mğŸ§¹ Bereinigter \$PATH:\033[0m"
echo "$new_path"

# â“ Abfrage: Soll der neue PATH sofort aktiviert werden?
read "confirm?MÃ¶chtest du diesen PATH jetzt aktivieren? [y/N] "
if [[ "$confirm" =~ ^[Yy]$ ]]; then
  export PATH="$new_path"
  echo -e "\nâœ… Neuer \$PATH aktiv.\n"
else
  echo -e "\nâŒ Abgebrochen. \$PATH bleibt unverÃ¤ndert.\n"
fi
